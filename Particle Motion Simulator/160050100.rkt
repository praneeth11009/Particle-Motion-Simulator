#lang racket
(provide buildTree)
(provide calcForces)
(provide moveparticles)
(require "declarations.rkt")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (in-box? part box)
    (let*((pos (particle-posn part))
          (x (vec-x pos))
          (y (vec-y pos)))
          (and (< x (bbox-rux box))(<= (bbox-llx box) x)(< y (bbox-ruy box))(<= (bbox-lly box) y))))
(define (parts ps box) (if (null? ps) '() (if (in-box? (car ps) box) (cons (car ps) (parts (cdr ps) box)) (parts (cdr ps) box))))
(define (buildTree box ps)
    (let* ((x0 (bbox-llx box))
         (y0 (bbox-lly box))
         (x1 (bbox-rux box))
         (y1 (bbox-ruy box))
         (mpx (/ (+ x1 x0) 2))
         (mpy (/ (+ y0 y1) 2))
         (b2 (bbox mpx mpy x1 y1)) 
         (b1 (bbox x0 mpy mpx y1)) 
         (b3 (bbox x0 y0 mpx mpy)) 
         (b4 (bbox mpx y0 x1 mpy))) 
    (cond ((null? ps) (gnode 0 (vec mpx mpy) '()))
          ((= 1 (length ps)) (car ps))
          (else (let*((list-of-subs (list (buildTree b1 (parts ps b1)) (buildTree b2 (parts ps b2))(buildTree b3 (parts ps b3)) (buildTree b4 (parts ps b4))))
                     (list-of-m (map (lambda(x)(if(particle? x)(particle-mass x)(gnode-mass x))) list-of-subs))
                     (list-of-pos (map (lambda(x)(if(particle? x)(particle-posn x)(gnode-posn x))) list-of-subs))
                      (m (foldl + 0 list-of-m)))
                       (gnode m (vec (/ (foldl + 0 (zipwith * list-of-m (map (lambda(x)(vec-x x)) list-of-pos))) m)
                                     (/ (foldl + 0 (zipwith * list-of-m (map (lambda(x)(vec-y x)) list-of-pos))) m))
                   list-of-subs))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (same? par tree) (and (equal? (posn par) (posn tree)) 
                              (= (mass par)(mass tree)))) 
(define (contains box tree)
   (define (search x tree)  
                           (cond ((particle? tree) (and(equal? (gnode-posn x) (particle-posn tree))(= (gnode-mass x) (particle-mass tree))))
                                 (else (or (and(equal? (gnode-posn x) (gnode-posn tree))(= (gnode-mass x) (gnode-mass tree)))
                                        (if (null? (gnode-subtrees tree)) #f
                                           (or (contains box (car (gnode-subtrees tree)))
                                               (contains box (gnode (gnode-mass tree)(gnode-posn tree)(cdr (gnode-subtrees tree))))))))))
(search (if (particle? box) (gnode (particle-mass box) (particle-posn  box) '()) box) tree))
(define (subtree box list)
   (if (contains box (car list)) (car list) (subtree box (cdr list))))
  
(define (level box tree) (if (equal? box tree) 1 (+ 1 (level box (subtree box (gnode-subtrees tree))))))
(define (posn box)(if(gnode? box)(gnode-posn box)(particle-posn box)))
(define (mass tree) (if(gnode? tree)(gnode-mass tree)(particle-mass tree)))
(define G (* g 1.0184790422356031))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (calcForces area tree particles)
 (define (far? par box) (let* ((pos2 (posn box))(pos1 (particle-posn par))
                               (dx (- (vec-x pos1) (vec-x pos2)))
                               (dy (- (vec-y pos1) (vec-y pos2)))
                               (d (sqrt (+ (* dx dx) (* dy dy))))
                               (s (/ (- (bbox-rux area)(bbox-llx area)) (expt 2 (- (level box tree) 1)))))
                           (> (/ d s) 2)))
  (define (calc-helper par tree)
    (cond ((same? par tree) (vec 0 0))
          ((or (particle? tree) (far? par tree))
                          (let* ((pos1 (posn tree))(pos2 (particle-posn par))
                                 (dx (- (vec-x pos1) (vec-x pos2)))
                                 (dy (- (vec-y pos1) (vec-y pos2)))
                                 (d (sqrt (+ (* dx dx) (* dy dy))))
                                 (F (*  g (particle-mass par) (mass tree) (/ 1 (* d d d)))))
                                   (vec (* dx F) (* dy F))))
          (else (foldr (lambda(x y)(vec (+ (vec-x x)(vec-x y))(+ (vec-y x)(vec-y y)))) (vec 0 0) (map (lambda(x)(calc-helper par x)) (gnode-subtrees tree))))))
  
  (if (null? particles) '() (cons (calc-helper (car particles) tree) (calcForces area tree (cdr particles))))) 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (moveparticles particles forces)
  (let* ((t timeslice))
     (define (move-single par force)
      (let* ((m (particle-mass par))
             (ax (/ (vec-x force) m))
             (ay (/ (vec-y force) m))
             (pos (particle-posn par))
             (v (particle-velocity par))
             (x0 (vec-x pos))
             (y0 (vec-y pos))
             (vx (vec-x v))
             (vy (vec-y v)))
      (particle m (vec (+ x0 (* vx t) (* .5 ax t t))(+ y0 (* vy t)(* .5 ay t t))) (vec (+ vx (* ax t)) (+ vy (* ay t))))))
    (if (null? particles) '() (cons (move-single (car particles)(car forces)) (moveparticles (cdr particles) (cdr forces))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
